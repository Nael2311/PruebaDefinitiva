
// Se ha construido correctamente el dia 5/11/2024 a las 14:23


#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "dht20.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "sdkconfig.h" // generated by "make menuconfig"
#include "ssd1306.h"
#include "font8x8_basic.h"
#include "lmic.h"
#include "hal.h"
#include "driver/spi_master.h"

// DevEUI, AppEUI y AppKey configurados en TTN
static const u1_t DEVEUI[8] = {0xC5, 0xB4, 0x06, 0xD0, 0x7E, 0xD5, 0xB3, 0x70}; // lsb
static const u1_t APPEUI[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const u1_t APPKEY[16] = {0x52, 0x8E, 0xD3, 0x67, 0x01, 0xC1, 0x23, 0xC3, 0x95, 0x45, 0x35, 0x62, 0x52, 0x53, 0xBF, 0xF2}; // msb

//static const char *TAG = "LoRa-Example";

static uint8_t mydata[64];
static osjob_t sendjob;

// SPG30
#define SGP30_ADDR 0x58  // Dirección I2C del SGP30
#define OLED_I2C_ADDRESS 0x3C // Direccion I2C del ssd1306
#define ACK_CHECK_EN 0x1 // Habilitar ACK
static const char *TAGSPG30 = "SGP30";
esp_err_t sgp30_write_command(uint16_t command);
esp_err_t sgp30_read_data(uint16_t *co2_eq, uint16_t *tvoc);

#define SDA_PIN GPIO_NUM_21
#define SCL_PIN GPIO_NUM_22

// Definición de la pantalla OLED, ajusta estas constantes según tu configuración
#define SSD1306_MAX_PAGES 4 // Número de páginas en la pantalla (ajustar si es necesario)
#define SSD1306_WIDTH 128   // Ancho de la pantalla en píxeles
#define SSD1306_HEIGHT 32   // Alto de la pantalla en píxeles
#define TAG "SSD1306"

uint8_t cur_page = 0;

TaskHandle_t read_data_h;
void dht20_read_task(void *param);

// typedef struct
// {
//     int _address;
//     int _width;
//     int _height;
//     int _pages;
//     int _dc;
//     bool _scEnable;
//     int _scStart;
//     int _scEnd;
//     int _scDirection;
//     int _page[8];
//     bool _flip;
//     i2c_port_t _i2c_num;
// } SSD1306_t;

// Schedule TX every this many seconds (might become longer due to duty
// cycle limitations).
const unsigned TX_INTERVAL = 60;

void os_getArtEui(u1_t *buf) { memcpy(buf, APPEUI, 8); }
void os_getDevEui(u1_t *buf) { memcpy(buf, DEVEUI, 8); }
void os_getDevKey(u1_t *buf) { memcpy(buf, APPKEY, 16); }

const lmic_pinmap lmic_pins = {
    .nss = 5,
    .rst = 16,
    .dio[0] = 2,
    .dio[1] = 15,  
    .spi[0] = 19, // MISO
    .spi[1] = 23, // MOSI
    .spi[2] = 18, // SCK
    .rxtx = LMIC_UNUSED_PIN,
};

void do_send(osjob_t *j)
{
    if (LMIC.opmode & OP_TXRXPEND)
    {
        ESP_LOGI("LoRa", "OP_TXRXPEND, not sending");
    }
    else
    {
        // Envía los datos formateados en `mydata`
        LMIC_setTxData2(1, (uint8_t *)mydata, strlen((char *)mydata), 1); //Si se establece a 1, la transmisión será confirmada (el servidor enviará un acuse de recibo). 
                                                                          //Si se establece a 0, la transmisión es sin confirmación.
        ESP_LOGI("LoRa", "Packet queued with data: %s", mydata);
    }
}

void onEvent(ev_t ev)
{
    ESP_LOGI("LoRa", "%ld: ", os_getTime()); // Imprime el tiempo

    switch (ev)
    {
    case EV_SCAN_TIMEOUT:
        ESP_LOGI("LoRa", "EV_SCAN_TIMEOUT");
        break;
    case EV_BEACON_FOUND:
        ESP_LOGI("LoRa", "EV_BEACON_FOUND");
        break;
    case EV_BEACON_MISSED:
        ESP_LOGI("LoRa", "EV_BEACON_MISSED");
        break;
    case EV_BEACON_TRACKED:
        ESP_LOGI("LoRa", "EV_BEACON_TRACKED");
        break;
    case EV_JOINING:
        ESP_LOGI("LoRa", "EV_JOINING");
        break;
    case EV_JOINED:
        ESP_LOGI("LoRa", "EV_JOINED");

        // Desactiva la verificación de enlace para TTN
        LMIC_setLinkCheckMode(0);
        break;
    case EV_RFU1:
        ESP_LOGI("LoRa", "EV_RFU1");
        break;
    case EV_JOIN_FAILED:
        ESP_LOGI("LoRa", "EV_JOIN_FAILED");
        break;
    case EV_REJOIN_FAILED:
        ESP_LOGI("LoRa", "EV_REJOIN_FAILED");
        break;
    case EV_TXCOMPLETE:
        ESP_LOGI("LoRa", "EV_TXCOMPLETE (includes waiting for RX windows)");
        if (LMIC.txrxFlags & TXRX_ACK)
            ESP_LOGI("LoRa", "Received ack");
        if (LMIC.dataLen)
        {
            ESP_LOGI("LoRa", "Received %d bytes of payload", LMIC.dataLen);
        }
        // Programa la siguiente transmisión
        os_setTimedCallback(&sendjob, os_getTime() + sec2osticks(TX_INTERVAL), do_send);
        break;
    case EV_LOST_TSYNC:
        ESP_LOGI("LoRa", "EV_LOST_TSYNC");
        break;
    case EV_RESET:
        ESP_LOGI("LoRa", "EV_RESET");
        break;
    case EV_RXCOMPLETE:
        ESP_LOGI("LoRa", "EV_RXCOMPLETE");
        break;
    case EV_LINK_DEAD:
        ESP_LOGI("LoRa", "EV_LINK_DEAD");
        break;
    case EV_LINK_ALIVE:
        ESP_LOGI("LoRa", "EV_LINK_ALIVE");
        break;
    default:
        ESP_LOGI("LoRa", "Unknown event");
        break;
    }
}

void lmic_task(void *pvParameter)
{
    while (1)
    {
        os_runloop_once(); // Ejecuta una iteración de LMIC
        vTaskDelay(pdMS_TO_TICKS(100));     // Permite otras tareas
    }
}

void i2c_oled_init()
{
    SSD1306_t dev; // Crea una instancia de SSD1306_t
    dev._i2c_num = I2C_NUM_0;
    dev._address = 0x3C;
    dev._width = SSD1306_WIDTH;
    dev._height = SSD1306_HEIGHT;
    dev._pages = 4; // Para OLED de 128x32

    // Inicializa el comando I2C para la OLED
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev._address << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_OFF, true); // Apagar la pantalla
    i2c_master_write_byte(cmd, OLED_CMD_SET_MUX_RATIO, true);
    i2c_master_write_byte(cmd, 0x1F, true); // 32 píxeles
    i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_OFFSET, true);
    i2c_master_write_byte(cmd, 0x00, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_START_LINE, true);

    i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP_1, true); // Mapeo de segmentos
    i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true);   // Modo de escaneo
    i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_CLK_DIV, true);
    i2c_master_write_byte(cmd, 0x80, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_COM_PIN_MAP, true);
    i2c_master_write_byte(cmd, 0x02, true); // Mapeo de pines COM para 32 píxeles
    i2c_master_write_byte(cmd, OLED_CMD_SET_CONTRAST, true);
    i2c_master_write_byte(cmd, 0xFF, true);
    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_RAM, true); // Modo RAM
    i2c_master_write_byte(cmd, OLED_CMD_SET_VCOMH_DESELCT, true);
    i2c_master_write_byte(cmd, 0x40, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_MEMORY_ADDR_MODE, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_PAGE_ADDR_MODE, true); // Modo de dirección de página
    i2c_master_write_byte(cmd, 0x00, true);                        // Dirección de columna baja
    i2c_master_write_byte(cmd, 0x10, true);                        // Dirección de columna alta
    i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
    i2c_master_write_byte(cmd, 0x14, true); // Habilitar la bomba de carga
    i2c_master_write_byte(cmd, OLED_CMD_DEACTIVE_SCROLL, true);
    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_NORMAL, true); // Modo normal
    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);     // Encender la pantalla

    i2c_master_stop(cmd);

    esp_err_t res = i2c_master_cmd_begin(dev._i2c_num, cmd, 100);
    if (res == ESP_OK)
    {
        ESP_LOGI("OLED", "OLED configured successfully");
    }
    else
    {
        ESP_LOGE("OLED", "OLED configuration failed. code: 0x%.2X", res);
    }
    i2c_cmd_link_delete(cmd);
}

void task_ssd1306_display_clear(void *ignore)
{
    i2c_cmd_handle_t cmd;
    uint8_t zero[128] = {0}; // Buffer de 128 ceros para limpiar cada línea

    for (uint8_t i = 0; i < 8; i++) // Limpiar las 8 páginas (líneas) de la pantalla
    {
        cmd = i2c_cmd_link_create();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true); // Seleccionar página (línea)

        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        i2c_master_write(cmd, zero, 128, true); // Escribir 128 ceros en la línea
        i2c_master_stop(cmd);
        // Aumentar el tiempo de espera para garantizar la comunicación
        i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(100));
        i2c_cmd_link_delete(cmd);
    }

    // Borrar la tarea una vez completada
    vTaskDelete(NULL);
}

void task_ssd1306_display_text(void *arg_text)
{
    char *text = (char *)arg_text;
    uint8_t text_len = strlen(text);

    i2c_cmd_handle_t cmd;

    // CON ESTO DEFINO LAS PAGINAS QUE QUIERO QUE SE ESCRIBAN
    if (cur_page > 3)
    {
        cur_page = 0;
    }

    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x00, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page

    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(10));
    i2c_cmd_link_delete(cmd);

    for (uint8_t i = 0; i < text_len; i++)
    {
        if (text[i] == '\n')
        {
            cmd = i2c_cmd_link_create();
            i2c_master_start(cmd);
            i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

            i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
            i2c_master_write_byte(cmd, 0x00, true); // reset column
            i2c_master_write_byte(cmd, 0x10, true);
            i2c_master_write_byte(cmd, 0xB0 | ++cur_page, true); // increment page

            i2c_master_stop(cmd);
            i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(10));
            i2c_cmd_link_delete(cmd);
        }
        else
        {
            cmd = i2c_cmd_link_create();
            i2c_master_start(cmd);
            i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

            i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
            i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);

            i2c_master_stop(cmd);
            i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(10));
            i2c_cmd_link_delete(cmd);
        }
    }

    cur_page++;
    vTaskDelete(NULL);
}

void dht20_read_task(void *param)
{
    static const char *tag = "dht20_read_task";
    ESP_LOGI(tag, "Entering measerument loop");

    static dht20_data_t measurements;

    char temp_str[20];
    char humid_str[20];

    uint16_t co2_eq, tvoc;

    // Cadenas para almacenar las lecturas
    char co2_str[20];
    char tvoc_str[20];

    while (1)
    {
        if (dht20_is_calibrated())
        {
            ESP_LOGI(tag, "is calibrated....");
        }
        else
        {
            ESP_LOGI(tag, "is NOT calibrated....");
        }
        
        ESP_ERROR_CHECK(sgp30_write_command(0x2008)); // Comando Measure_air_quality
        ESP_ERROR_CHECK(sgp30_read_data(&co2_eq, &tvoc));

        (void)dht20_read_data(&measurements);
        ESP_LOGI(tag, "Temperature:\t%.1fC.\t Avg: %.1fC", measurements.temperature, measurements.temp_avg);
        ESP_LOGI(tag, "Humidity:   \t%.1f%%.\t Avg: %.1f%%\n", measurements.humidity, measurements.humid_avg);

        // Convertir los valores de temperatura y humedad a cadenas
        snprintf(temp_str, sizeof(temp_str), "Temp: %.1fC", measurements.temperature);
        snprintf(humid_str, sizeof(humid_str), "Hum: %.1f%%", measurements.humidity);

        // Limpiar la pantalla antes de escribir nuevo contenido
        xTaskCreate(task_ssd1306_display_clear, "ssd1306_display_clear", 2048, NULL, 6, NULL);
        vTaskDelay(pdMS_TO_TICKS(100)); // Esperar a que se limpie la pantalla

        // Mostrar la temperatura en la pantalla OLED
        xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text", 2048, (void *)temp_str, 6, NULL);
        vTaskDelay(pdMS_TO_TICKS(10)); // Esperar un poco antes de escribir la siguiente línea

        // Mostrar la humedad en la pantalla OLED
        xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text", 2048, (void *)humid_str, 6, NULL);
        vTaskDelay(pdMS_TO_TICKS(10)); // Esperar un poco antes de seguir

        ESP_LOGI(TAGSPG30, "CO2eq: %d ppm, TVOC: %d ppb", co2_eq, tvoc);

        snprintf(co2_str, sizeof(co2_str), "CO2eq: %d ppm", co2_eq);
        snprintf(tvoc_str, sizeof(tvoc_str), "TVOC: %d ppb", tvoc);

        // Mostrar CO2eq en la tercera página
        xTaskCreate(task_ssd1306_display_text, "display_co2", 2048, (void *)co2_str, 5, NULL);
        vTaskDelay(pdMS_TO_TICKS(10)); // Esperar un poco antes de escribir la siguiente línea

        // Mostrar TVOC en la cuarta página
        xTaskCreate(task_ssd1306_display_text, "display_tvoc", 2048, (void *)tvoc_str, 5, NULL);

        // Preparar el payload para enviar datos por loRaWAN
        snprintf((char *)mydata, sizeof(mydata), "T:%.1f H:%.1f CO2:%d TVOC:%d", 
                 measurements.temperature, measurements.humidity, co2_eq, tvoc);

        // Llamar a la función `do_send` para transmitir
        do_send(&sendjob); //Transmisión OTAA

        vTaskDelay(pdMS_TO_TICKS(2000)); // Esperar 2 segundos antes de la próxima lectura
    }
}

// Función para escribir comandos al sensor
esp_err_t sgp30_write_command(uint16_t command)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (SGP30_ADDR << 1) | I2C_MASTER_WRITE, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, (command >> 8) & 0xFF, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, command & 0xFF, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    return ret;
}

// Función para leer los datos del sensor
esp_err_t sgp30_read_data(uint16_t *co2_eq, uint16_t *tvoc)
{
    uint8_t data[6];
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (SGP30_ADDR << 1) | I2C_MASTER_READ, ACK_CHECK_EN);
    i2c_master_read(cmd, data, sizeof(data) - 1, I2C_MASTER_ACK);
    i2c_master_read_byte(cmd, data + 5, I2C_MASTER_NACK); // CRC (no usado aquí)
    i2c_master_stop(cmd);
    vTaskDelay(pdMS_TO_TICKS(100)); // MUY IMPORTANTE ESTE RETARDO DE 100 mS
    esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);

    if (ret == ESP_OK)
    {
        *co2_eq = (data[0] << 8) | data[1];
        *tvoc = (data[3] << 8) | data[4];
    }
    return ret;
}

/*
void app_main(void)
{
    // Inicialización del log y mensaje de arranque
    ESP_LOGI("LoRa", "Starting");

    // Inicialización de LMIC
    os_init();
    // Reinicio del estado de MAC (descarta sesiones y transferencias pendientes)
    LMIC_reset();

    dht20_begin(); // NO HACE FALTA CONFIGURAR EL I2C YA QUE SE ESTA HACIENDO EN ESTA FUNCION Y SOLO HACE FALTA UNA VEZ
    i2c_oled_init();

    ESP_ERROR_CHECK(sgp30_write_command(0x2003)); // Comando Init_air_quality

    // Define el texto que deseas mostrar
    char *init_message = "    POR FAVOR\n\n     ESPERE";

    // Limpiar la pantalla antes de escribir nuevo contenido
    xTaskCreate(task_ssd1306_display_clear, "ssd1306_display_clear", 2048, NULL, 6, NULL);
    vTaskDelay(pdMS_TO_TICKS(100)); // Esperar a que se limpie la pantalla

    // Crea la tarea para mostrar el mensaje en la pantalla OLED
    xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text", 2048, (void *)init_message, 6, NULL);

    vTaskDelay(pdMS_TO_TICKS(15000)); // Esperar los primeros 15 segundos

    // Se vuelve a poner la pagina de la pantalla a 0
    cur_page = 0;

    xTaskCreate(dht20_read_task, "read_values", (256 * 11), NULL, tskIDLE_PRIORITY, &read_data_h); // Inicializar el sensor SGP30

    
    ESP_LOGI("LoRa", "AQUI LLEGA 0");

    // Inicia la primera transmisión, que también lanza el proceso OTAA
    do_send(&sendjob);

    ESP_LOGI("LoRa", "AQUI LLEGA 1");

    // Crea la tarea LMIC que actúa como el bucle `loop()`
    xTaskCreate(&lmic_task, "lmic_task", 2048, NULL, 5, NULL);

    ESP_LOGI("LoRa", "AQUI LLEGA 2");
}
*/

void initialize_peripherals() {
    dht20_begin(); // Inicializar DHT20
    i2c_oled_init(); // Inicializar pantalla OLED
    ESP_ERROR_CHECK(sgp30_write_command(0x2003)); // Comando Init_air_quality
}

void display_initial_message() {
    // Mensaje inicial
    const char *init_message = "    POR FAVOR\n\n     ESPERE";
    task_ssd1306_display_clear(NULL);  // Llama directamente si solo necesitas limpiar una vez
    vTaskDelay(pdMS_TO_TICKS(100)); // Espera a que se limpie la pantalla
    task_ssd1306_display_text((void *)init_message); // Muestra mensaje sin necesidad de una tarea extra
}

void app_main(void)
{
    ESP_LOGI("LoRa", "Starting");

    // Inicializar LMIC
    os_init();
    LMIC_reset(); // Reinicia el estado de la MAC
    
    // Inicializar periféricos
    initialize_peripherals();

    // Mostrar mensaje inicial en la pantalla
    display_initial_message();

    // Espera inicial antes de iniciar tareas de sensores
    vTaskDelay(pdMS_TO_TICKS(15000)); 

    // Se vuelve a poner la pagina de la pantalla a 0
    cur_page = 0;

    // Crear tareas para lectura de sensores y transmisión LoRa
    xTaskCreate(dht20_read_task, "read_values", 256 * 11, NULL, 3, &read_data_h); 
    xTaskCreate(&lmic_task, "lmic_task", 2048, NULL, 5, NULL); // Tarea LMIC

    ESP_LOGI("LoRa", "Tareas inicializadas");
}